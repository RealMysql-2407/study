#  transaction
mysql 동시성에 영향을 미치는 것들 
잠금(Lock)과 트렌젝션, 트렌젝션 격리수준

잠금은 동시성을 보장해주기 위한 기능, 여러 커넥션에서 동시에 동일한 자원을 요청할 경우, 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할

## 5.1 트렌잭션
트렌젝션은 (여러 개의 쿼리가 묶인) 한 작업 단위의 완정성, 데이터의 정합성을 보장하기 위한 기능, 하나의 트렌젝션 혹은 여러 트렌젝션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨

MYISAM, MEMORY는 트렌젝션 제공 안함. InnoDB는 제공함. 트렌젝션의 의미를 이해하기 위해서 두 엔진으로 실험을 해보자.

`Create table test_myisam (fdpk int not null , primary key (fdpk)) engine = MYISAM;`

`Create table test_innodb (fdpk int not null , primary key (fdpk)) engine = InnoDB;`

`Insert into test_myisam (fdpk) values (3)`

`Insert into test_innodb (fdpk) values (3)`

`Insert into test_myisam (fdpk) values (1),(2),(3)`

`Insert into test_innodb (fdpk) values (1),(2),(3)`

이렇게 하면 myisam의 경우에는 테이블에 1,2,3이 남아있고, test_innodb에는 3만 남아있다. 

myisam에서 발생하는 이런 이슈를 partial update라고 한다. 이런 부분 업데이트가 이뤄진다면 2개 이상의 쿼리 실행시 데이터 제거 작업이 필요해진다.

### 5.1.2 주의사항
트랜젝션 또한 DBMS 커넥션과 마찬가지로 최소한만 사용하는게 좋다. 
- 커넥션의 범위를 db데이터에 저장하는 시점으로 좁히자. 검증로직, 파일저장 등은 커넥션 맺기 + 트렌젝션 밖으로 빼자. 일반적으로 데이터베이스 커넥션 갯수는 제한적이다. 그러므로 각 프로그램이 커넥션을 소유하는 시간이 길어질수록, 여유 커넥션 수는 줄어들 수 밖에 없다.
- 외부 서버와 통신하는 로직은 트렌젝션 밖으로 빼자. 외부서버와 통신이 끊기면, DBMS 서버까지 위험해지는 상황이 발생할 것이다.
- 조회 쿼리와 명령 쿼리는 트렌젝션을 분리하는 것이 좋다. 그리고 조회의 경우 ReadOnly를 사용하는게 바람직하다.

위 사항들을 잘 지킨 로직의 예시는 다음과 같다. 
```
1) 처리 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용 검증
4) 첨부로 업로드된 파일 확인 및 저장 
=> 데이터베이스 커넥션 생성(또는 커넥션 풀에서 가져오기)
=> 트랜젝션 시작
5) 사용자 입력 정보 DBMS 저장
6) 첨부 파일 정보 DBMS 저장
<= 트렌젝션 종료(commit)
7) 저장된 내용 조회
8) 게시물 등록에 대한 알림 메일 전송
=> 트랜젝션 시작
9) 알림 메일 발송 이력 DBMS 저장
<= 트랜젝션 종료
<= 데이터베이스 커넥션 종료 ( 혹은 커넥션 풀에 반납)
10) 처리완료 
```
## 5.2 Mysql 엔진의 잠금
- 스토리지 엔진 레벨과
- mysql 엔진 레벨
  - 테이블 락
  - 메타데이터 락(테이블 구조 잠금)
  - 네임드 락(사용자 필요에 맞게 사용 가능)

### 5.2.1 글로벌 락
flush tables with read lock 명령으로 획득이 가능하다. mysql 에서 제공하는 잠금 가운데 가장 범위가 크다.

한 곳에서 글로벌 락을 획득하면 select 를 제외한 모든 ddl문장이나 dml문장을 실행하는 경우 해당 문장이 대기 상태로 남는다.

mysqlDump할 때, 데이터 일관성 유지를 위해서 사용할 수 있다. 

웹서비스에서 사용되는 mysql 서버에서는 되도록 사용하지 않는 것이 좋다. mysqldump할 때도 어떤 잠금을 사용하는지 확인해보면 좋다. 

innodb에서는 myslq 8.0이상부터는 백업락이 그래서 도입되었다. 
특정 세션에서 백업락을 도입하면 모든 세션에서는 다음과 같이 테이블 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 된다.
- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경 삭제
- REPAIR TABLE과 OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경
하지만 테이블락은 일반적인 테이블 데이터 변경은 허용된다. 

일반적인 mysql 서버 구성은 소스 서버(Source server)와 레플리카 서버(Replica server)로 구성된다. 주로 백업은 레플리카 서버에서 실행된다.

만약 글로벌 락을 걸면 레플리카 서버의 복제는 백업이 진행될 동안 멈추게 된다. 그리고 만약 그 때 소스 버서에 장애가 터지면, 레플리카 서버의 데이터가 최신으로 업데이트 될 때까지 장애가 지속될 수 있다.

물론 백업툴들은 복제가 진행되는 상태에서도 백업락을 활용해서 백업을 만들 수 있다. 하지만 글로벌 락을 사용하지 않고 백업락을 사용할 경우, 실행되는 도중 스키마 구조가 변경되면 실패할 수 있다.
-> 6~7시간 백업 진행하고 있는데, DDL 명령 하나로 실패처리 될 수 있는 것이다!!!!

> ddl은 데이터 베이스, 테이블 관련 명령어. dml은 데이터 조작과 관련된 명령어 말한다. 

### 5.2.2 테이블 락 
개별 테이블 별로 설정되는 잠금.
명시적으로는 `Lock Tables table_name[READ | WRITE]`로 얻을 수 있다. 
명시적으로 획득한 잠금은 `unlock tables` 명령어로 잠금을 해제할 수 있다. 명시적 락은 특별한 상황이 아니면 어플리케이션 에서 사용할 필요가 없다. 

묵시적 락의 경우 MYISAM이나, MEMORY 테이블에 데이터를 변경하면 생겼다가 변경이 끝나면 사라진다. 
하지만 InnoDB의 경우에는 스토리지 엔진 차원에서 레코드 기반 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않는다. 
DDL 에서만 영향을 미친다. 

### 5.2.3 네임드 락 
`GET_LOCK()`함수를 이용해서 임이의 문자열에 대해 잠금을 설정할 수 있다. 
이락의 특징은 대상이 테이블, 레코드 또는 Auto_INCREMENT와 같은 데이터베이스 객체가 아니라는 점이다. 
네임드 락은 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 잠금이다. 

복잡한 요건으로 레코드 변경하는 트랜잭션에 유용할 수 있다. 배치는 한번에 여러 쿼리 실행하면서 데드락의 원인이 되곤 한다.
이 때, 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드락을 걸고 쿼리를 실행하면 간단하게 해결 가능하다.

mysql 8.0부터는 네임드락을 여러개 동시에 사용할 수 있다고 합니다.

### 5.2.4 메타데이터 락
데이터베잇 객체(테이블, 뷰)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다. 메타데이터 락은 명시적으로 획득 해제는 불가능하다.
`RENAME TABLE tab_a TO tab_b`와 같이 테이블 이름을 변경하는 경우에 자동으로 획득, 해제되는 락이다. 

## 5.3 innoDB 스토리지 엔진 잠금
innoDB 스토리지 엔진은 mysql 에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.

innoDB는 레코드 기반 잠금 방식 때문에 MYISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다. 
하지만 이원화된 잠금 처리 탓에 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MYSQL 명령을 이용해 접근하기가 상당히 까다롭다.
하지만 최근 버전에서는 `information_schema(더 최근에는 performance schema)` 데이터베이스에 존재하는 `INNODB_TRX, INNODB_LOCKS, INNODB_WAITS`라는 테이블을 조인해서 확인할 수 있다. 

장시간 잠금을 가지고 있는 클라이언트를 찾아서 해제할 수 있다. 

## 5.3.1 InnoDb 스토리지 엔진의 잠금
레코드 기반의 잠금 기능을 제공한다.
InnoDB의 레코드 락(Record Lock)은 정확히 말하면 테이블의 특정 행(레코드)에 대해 락을 거는 것을 의미합니다. 이는 데이터베이스 트랜잭션의 ACID 속성을 보장하기 위한 중요한 기능
잠금 정보가 상당히 작은 공간으로 관리된다. 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우는 없다.

레코드와 레코드 사이의 간격을 잠그는 갭락이라는 것도 있다. 

그리고 갭락 + 레코드 락= 넥스트 키 락 도 있다. 

### 5.3.1.1 레코드 락
레코드 자체만을 잠그는 것을 레코드 락이라고 한다. 
레코드 자체가 아니라, 인덱스의 레코드를 잠근다. 인덱스가 하나도 없는 테이블이더라도, 내부적으로 자동 생성된 클러스터 인덱스를 사용해서 잠근다.
프라이머리키, 혹은 유닉크 인덱스에 대한 변경 작업에서는 레코드 락을 사용한다.

### 5.3.1.2 갭락
레코드와 레코드 사이에 새로운 레코드가 생성되는 것을 막는 역할을 한다. 
갭락은 그 자체로보다는 넥스트 키락 설명의 일부로 같이 사용된다.

### 5.3.1.3 넥스트 키 락
바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장해주는 것이 목적이다. 

근데 이로 인해서 데드락이 걸리거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다. 

가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

### 5.3.1.4 자동 증가락
AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 중복되지 않고 증가 된 채 저장해야한다. 
이를 위해서 InnoDB 스토리지 엔진에서는 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용한다.

이는 INSERT, REPLACE와 같이 새로운 레코드 저장 쿼리에서만 필요하다. 트랜젝션과 상관없이 INSERT, REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다 즉시 해제된다.

만약 AUTO_INCREMENT 칼럼에 값을 직접 할당하더라도 락이 걸리게 된다.

명시적으로 획득하고 해제하는 방법은 없다. 

5.1 이상 버전에서는 만약 MYSQL 서버가 INSERT 되는 레코드의 건수를 정화하게 알 수 있다면 자동 증가 락을 사용하지 않는다. 훨씬 빠른 뮤텍스를 이용해 처리한다.

### 5.3.2 인덱스와 잠금
InnoDB의 레코드 락은 레코드를 잠그는 것이 아니라 인데스를 잠그는 방식으로 처리된다.
즉 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락 걸어야 한다. 

만약 인덱스가 없다면 ? 풀스캔하면서 모든 레코드를 잠근다 ㄷㄷ;;

### 5.3.3 레코드 수준의 잠금 확인과 해제 

---

## 5.4 MYSQL 격리 수준
READ UNCOMMITED(DIRTY READ)는 일반적인 데이터베이스에서는 거의 사용하지 않는다. 
SERIALIZABLE 또한 동시성이 중요한 데이터베이스에서는 거의 사용되지 않는다. 

격리수준이 높아질수록 성능저하가 일어나긴 하지만, SERIALIZABLE이 아니면 크게 떨어지지는 않는다.


NON-repeatable read , phantom read 문제를 알아보자.

### 5.4.1 READ UNCOMMITED
말 그래도 커밋 되기 전에 것을 읽는 것. 그래서 커밋 전에 롤백을 해도 정상 데이터라고 착각하게 된다.

### 5.4.2. READ COMMITED
오라클 디비에서 기본적으로 사용하는 격리 수준임.

더티리드 문제는 해결되지만, 트렌젝션 안에서 같은 데이터를 2번 읽을 때, 그 사이에 update가 이뤄지면 일치하지 않는 unrepeatable한 문제가 생긴다. 

금전적인 처리와 연관되면 문제가 될 수 있다.
### 5.4.3. REPEATABLE READ
mysql innoDB의 스토리지 엔진에서 기본적으로 사용되는 격리수준이다. 바이너리 로그를 가진 mysql 서버에서는 최소 repeatable read 이상의 격리수준을 사용해야 한다.

실행되고 있는 트렌젝션 번호의 구간 내에서 백업된 언두 데이터를 보존하고 있다. 그리고 처음 조회를 했을 때와 같은 데이터를 반환해준다. 

### 5.4.4 SERIALIZABLE 
딱 그 데이터에 대한 변경은 undo된 데이터로 보여줄 수 있지만, 하나의 데이터 조회가 아닌 범위 조회를 할 경우에는 그 데이터만 조회하는게 아니다. 
그러므로 새로운 INSERT가 일어날 경우 추가되어서 보이는 phatom read가 발생할 수 있다.  그래스 트렌젝션에 아예 접근 불가능하도록 한 것이 SERIALIZABLE 이다.

하지만 innoDB에서는 갭 락과 넥스트 키락 덕분에 REPEATABLE READ 격리 수준에서도 이미 PHANTOM READ 가 발생하지 않으므로 사용할 필요가 없다. 


